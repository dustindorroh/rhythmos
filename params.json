{"name":"Rhythmos","body":"# RhythmOS Reference\r\n\r\n## Table of Contents\r\n\r\n  * RhythmOS\r\n  * 1 Overview\r\n      * 1.0.1 RhythmOS Features\r\n      * 1.0.2 Source Code\r\n  * 2 Toolchain Setup\r\n    * 2.1 Build Environment\r\n    * 2.2 Source Download\r\n    * 2.3 Binutils\r\n    * 2.4 GCC\r\n    * 2.5 C Library\r\n  * 3 Building RhythmOS\r\n    * 3.1 Build Internals\r\n      * 3.1.1 Linking\r\n        * Linker Invocation\r\n        * link.ld\r\n      * Kernel Image\r\n      * Filesystem Image\r\n      * Bootloader Image\r\n  * 4 Running RhythmOS\r\n  * 5 Filesystems\r\n  * 6 Reporting bugs\r\n  * Concept index\r\n\r\n* * *\r\n\r\n\r\n## RhythmOS\r\n\r\nThis manual is for `RhythmOS` (version 74852df, 8 June 2012), which is a an\r\nattempt at a barebones unix-like kernel\r\n\r\n  * Overview: General purpose and information. \r\n  * Toolchain Setup: Build a RhythmOS Toolchain \r\n  * Building RhythmOS: Steps to compile and build RhythmOS. \r\n  * Running RhythmOS: Steps to run RhythmOS \r\n  * Programming the kernel\r\n  * Multitasking: Interrupt handling \r\n  * Memory: Paging and virtual memory \r\n  * Dynamic Memory Allocation\r\n  * System calls\r\n  * I/O\r\n  * Filesystems\r\n  * Reporting bugs: Sending bug reports and feature suggestions. \r\n\r\n--- The Detailed Node Listing --- \r\n\r\nOverview\r\n\r\n  * RhythmOS Features\r\n  * Source Code\r\n\r\nToolchain Setup\r\n\r\n  * Build Environment\r\n  * Source Download\r\n  * Binutils\r\n  * GCC\r\n  * C Library\r\n\r\nBuilding RhythmOS\r\n\r\n  * Build Internals\r\n\r\nBuild Internals\r\n\r\n  * Linking\r\n  * Kernel Image\r\n  * Filesystem Image\r\n  * Bootloader Image\r\n\r\nLinking\r\n\r\n  * Linker Invocation\r\n  * link.ld\r\n\r\nlink.ld\r\n\r\n  * Kernel Image\r\n  * Filesystem Image\r\n  * Bootloader Image\r\n\r\nProgramming the kernel\r\n\r\n  * Assembly\r\n  * C\r\n\r\nC\r\n\r\n  * The Run-Time Library\r\n\r\n* * *\r\n\r\n\r\n## 1 Overview\r\n\r\nThis manual is for `RhythmOS` (version 74852df, 8 June 2012), which is a an\r\nattempt at a barebones unix-like kernel. This document intends to cover the\r\nhow to build, use, and develop on Rhythmos as well as explain in depth some of\r\nthe kernel internals. For up to date news check the project home which is\r\nlocated at [https://github.com/dustindorroh/rhythmos/](https://github.com/dust\r\nindorroh/rhythmos/)\r\n\r\n  * RhythmOS Features\r\n  * Source Code\r\n\r\n* * *\r\n\r\n\r\n#### 1.0.1 RhythmOS Features\r\n\r\n  * Small C library \r\n  * Kernel mode and user mode \r\n  * Basic Multitasking through the use of context switches and memory protection \r\n  * Dynamic memory allocation (using buddy allocation technique) \r\n  * Virtual memory \r\n  * Kernel Paging \r\n  * UNIX-like system calls:  Process management: `fork`, `kill`, `execve`, `waitpid` ...\r\n    * Interprocess Communication (IPC): pipe, dup \r\n  * Read only filesystem \r\n\r\n* * *\r\n\r\n\r\n#### 1.0.2 Source Code\r\n\r\nUse git to clone a copy of the source tree. Use the command below to clone the\r\nRhythmOS repository.\r\n\r\n    \r\n         git clone https://github.com/dustindorroh/rhythmos.git\r\n    \r\n\r\n* * *\r\n\r\n\r\n## 2 Toolchain Setup\r\n\r\nBuild a RhythmOS Toolchain\r\n\r\nIf your native architecture is x86 then you will most likely already have a\r\ntoolchain that will work for RhythmOS. If your architecture is something else\r\nyou will have to build an toolchain to cross compile to x86.\r\n\r\nYou can find your architecture in Linux from one of the following commands:\r\n\r\n    \r\n         $ arch x86_64\r\n         \r\n         $ lscpu | grep Arch\r\n         Architecture:          x86_64\r\n         \r\n         $ uname -m\r\n         x86_64\r\n    \r\n\r\n  * Build Environment\r\n  * Source Download\r\n  * Binutils\r\n  * GCC\r\n  * C Library\r\n\r\n* * *\r\n\r\n\r\n### 2.1 Build Environment\r\n\r\nExport build variables\r\n\r\n    \r\n         $ export PREFIX=/usr/local/cross\r\n         $ export TARGET=i386-elf\r\n    \r\n\r\nCreate build directories for gcc binutils and newlibc\r\n\r\n    \r\n         $ mkdir -p build/{gcc,binutils,newlib}\r\n         $ sudo mkdir /usr/local/cross\r\n    \r\n\r\n* * *\r\n\r\n\r\n### 2.2 Source Download\r\n\r\nDownload and extract Binutils and gcc and newlibc\r\n\r\n    \r\n         $ wget http://ftp.gnu.org/gnu/binutils/binutils-2.21.1a.tar.bz2\r\n         $ wget http://ftp.gnu.org/gnu/gcc/gcc-4.6.2/gcc-4.6.2.tar.bz2\r\n         $ wget ftp://sources.redhat.com/pub/newlib/newlib-1.20.0.tar.gz\r\n         $ tar xjvf binutils-2.21.1a.tar.bz2\r\n         $ tar xjvf gcc-4.6.2.tar.bz2\r\n         $ tar xzvf newlib-1.20.0.tar.gz\r\n    \r\n\r\nDownload gmp mpfr and mpc required by gcc\r\n\r\n    \r\n         $ wget ftp://ftp.gmplib.org/pub/gmp-5.0.2/gmp-5.0.2.tar.bz2\r\n         $ wget http://www.mpfr.org/mpfr-current/mpfr-3.1.0.tar.bz2\r\n         $ wget http://www.multiprecision.org/mpc/download/mpc-0.9.tar.gz\r\n    \r\n\r\nExtract gmp mpfr and mpc into the gcc directory so that gcc will build them\r\nautomatically\r\n\r\n    \r\n         $ cd gcc-4.6.2\r\n         $ tar xjvf ../gmp-5.0.2.tar.bz2 && mv gmp-5.0.2/ gmp\r\n         $ tar xjvf ../mpfr-3.1.0.tar.bz2 && mv mpfr-3.1.0/ mpfr\r\n         $ tar xzvf ../mpc-0.9.tar.gz  && mv mpc-0.9/ mpc\r\n         $ cd ..\r\n    \r\n\r\n* * *\r\n\r\n\r\n### 2.3 Binutils\r\n\r\nConfigure Binutils\r\n\r\n    \r\n         $ cd build/binutils/\r\n         $ ../../binutils-2.21.1/configure --target=$TARGET \\\r\n                                           --prefix=$PREFIX \\\r\n                                           --disable-nls\r\n    \r\n\r\nMake and Install Binutils\r\n\r\n    \r\n         $ make all\r\n         $ sudo make install\r\n         $ cd ../..\r\n    \r\n\r\n* * *\r\n\r\n\r\n### 2.4 GCC\r\n\r\nSetup Environment\r\n\r\n    \r\n         $ export PATH=$PATH:$PREFIX/bin\r\n    \r\n\r\nConfigure GCC\r\n\r\n    \r\n         $ cd build/gcc\r\n         $ ../../gcc-4.6.2/configure  --target=$TARGET \\\r\n                                      --prefix=$PREFIX \\\r\n                                      --disable-nls \\\r\n                                      --enable-languages=c \\\r\n                                      --without-headers\r\n    \r\n\r\nMake And Install GCC\r\n\r\n    \r\n         $ make all-gcc\r\n         $ sudo make install-gcc\r\n         $ cd ../..\r\n    \r\n\r\n* * *\r\n\r\n\r\n### 2.5 C Library\r\n\r\nConfigure Newlib\r\n\r\n    \r\n         $ cd build/newlib\r\n         $ ../../newlib-1.20.0/configure --target=$TARGET \\\r\n                                         --prefix=$PREFIX\r\n    \r\n\r\nMake and Install Newlib\r\n\r\n    \r\n         $ make all\r\n         $ sudo make install\r\n    \r\n\r\nRun command below if `sudo make install` cant find utils in /usr/cross/bin\r\n\r\n    \r\n         $ sudo ln -s /usr/local/cross/bin/i386-elf-* /usr/local/bin\r\n         $ sudo make install\r\n    \r\n\r\n* * *\r\n\r\n\r\n## 3 Building RhythmOS\r\n\r\nFrom the top level project directory execute the configure script.\r\n\r\n    \r\n         $ ./configure\r\n    \r\n\r\nTo build everything just type `make'. This should build the kernel image\r\nkernel.img, the file system image filesystem.img, and the grub boot image\r\ngrub.img\r\n\r\n    \r\n         $ make\r\n    \r\n\r\nTo only build root file system type `make fs'. To only build the bootloader\r\ntype `make boot'.\r\n\r\n  * Build Internals\r\n\r\n* * *\r\n\r\nRhythmOS\r\n\r\n### 3.1 Build Internals\r\n\r\n  * Linking\r\n  * Kernel Image\r\n  * Filesystem Image\r\n  * Bootloader Image\r\n\r\n* * *\r\n\r\n\r\n#### 3.1.1 Linking\r\n\r\nThe linker combines input files into a single output file. The output file and\r\neach input file are in a special data format known as an object file format.\r\nEach file is called an object file. The output file is often called an\r\nexecutable, but for our purposes we will also call it an object file. Each\r\nobject file has, among other things, a list of sections. We sometimes refer to\r\na section in an input file as an input section; similarly, a section in the\r\noutput file is an output section.\r\n\r\nYou can see the sections in an object file by using the objdump program with\r\nthe -h option. Every object file also has a list of symbols, known as the\r\nsymbol table. A symbol may be defined or undefined. Each symbol has a name,\r\nand each defined symbol has an address.\r\n\r\n  * Linker Invocation\r\n  * link.ld\r\n\r\n* * *\r\n\r\n\r\n##### Linker Invocation\r\n\r\n    \r\n         # Link using link.ld\r\n         $(KERNEL_IMG): $(KERNEL_OBJECTS)\r\n             $(LD) -T link.ld -o $(KERNEL_IMG) $(KERNEL_OBJECTS)\r\n    \r\n\r\nThe -T option instructs the linker ld to use the commands in the script file\r\nlink.ld. It specifies the various segments used by the program. In the file we\r\nspecify 3 segments:\r\n\r\n•`.text` - Code segment\r\n\r\n•`.data` - Data segment\r\n\r\n•`.bss` - Stack segment\r\n\r\n* * *\r\n\r\n\r\n##### link.ld\r\n\r\n    \r\n         OUTPUT_FORMAT(\"binary\")\r\n         ENTRY(start)\r\n         phys = 0x00100000;\r\n         SECTIONS\r\n         {\r\n           .text phys : AT(phys) {\r\n             code = .;\r\n             *(.text)\r\n             *(.rodata)\r\n             . = ALIGN(4096);\r\n           }\r\n           .data : AT(phys + (data - code))\r\n           {\r\n             data = .;\r\n             *(.data)\r\n             . = ALIGN(4096);\r\n           }\r\n           .bss : AT(phys + (bss - code))\r\n           {\r\n             bss = .;\r\n             *(.bss)\r\n             . = ALIGN(4096);\r\n           }\r\n          . = ALIGN(4096);\r\n           end = .;\r\n         }\r\n    \r\n\r\nIn order for `RhythmOS` to be able to boot properly, three different binary\r\nimages are needed (see Building RhythmOS). The _images_ also have to be made\r\nin a particular order due to the build dependencies, thus the build process\r\nnaturally falls into a three step process:\r\n\r\n  1. Kernel Image (see Kernel Image) \r\n  2. Filesystem Image (see Filesystem Image) \r\n  3. Bootloader Image (see Bootloader Image) \r\n  * Kernel Image\r\n  * Filesystem Image\r\n  * Bootloader Image\r\n\r\n* * *\r\n\r\n\r\n#### Kernel Image\r\n\r\nExecuting make compiles individual source (`.c`) into object files (`.o`). The\r\nlinker (ld) is then used next to link the object files into one binary\r\nsrc/kernel.img. See Assembly.\r\n\r\n* * *\r\n\r\n\r\n#### Filesystem Image\r\n\r\nThe make fs target executes the build script mk_filesystem_image.sh located in\r\nsrc, the project's source directory.\r\n\r\nThe srcipt mk_filesystem_image.sh creates empty directories in the project\r\ntree, which will be a staging place for the root files that will be used by\r\nRhythmOS. Next, the programs that will run on the kernel (ie sh, ls, cat, etc\r\n... ) will be copied to the appropiate staging directory 1. An example of how\r\nrootfs might be structured.\r\n\r\n    \r\n         $ tree rootfs/\r\n         rootfs/\r\n         |-- bin\r\n         |   |-- cat\r\n         |   |-- find\r\n         |   |-- ls\r\n         |   |-- pwd\r\n         |   `-- sh\r\n         |-- etc\r\n         `-- usr\r\n    \r\n\r\nAn image, based off of the staging filesystem, is then built up in memory 2.\r\nWhen complete the filesystem image will be located src/filesystem.img.\r\n\r\n* * *\r\n\r\nInternals\r\n\r\n#### Bootloader Image\r\n\r\nIn order to run the kernel, it’s necessary to use a boot loader. This is the\r\nfirst thing that runs when a computer starts, and is responsible for loading\r\nthe kernel file into memory and instructing the processor to start executing\r\nit.\r\n\r\nThe grub.img is the GRUB image that we will as are bootloader. This file\r\ncontains our kernel image and our file system image.\r\n\r\n    \r\n         $ mkdir floppy\r\n         $ sudo mount src/grub.img floppy\r\n         $ tree floppy/\r\n         floppy/\r\n         |-- boot\r\n         |   `-- grub\r\n         |       |-- fat_stage1_5\r\n         |       |-- menu.lst\r\n         |       |-- stage1\r\n         |       `-- stage2\r\n         |-- filesystem.img\r\n         `-- kernel.img\r\n         \r\n         2 directories, 6 files\r\n    \r\n\r\nThe menu.lst contains the menu settings for GRUB along with the boot commands\r\nfor each entry.\r\n\r\n    \r\n         $ cat floppy/boot/grub/menu.lst\r\n         timeout 5\r\n         title RhythmOS\r\n         root (fd0)\r\n         kernel /kernel.img\r\n         modulenounzip (fd0)/filesystem.img\r\n         \r\n         $ sudo mount src/grub.img floppy\r\n    \r\n\r\nIf you can't mount grub.img to edit it this is OK because the grub.img that\r\ncomes with the source is already formated and for updating the image we use\r\n[Mtools](http://www.gnu.org/s/mtools/) which doesn't require special\r\npermissions. See below for details...\r\n\r\nUsing mk_boot_image.sh makes sure to delete the old kernel image and\r\nfilesystem image from the GRUB image. It then writes the kernel image\r\n(kernel.img) and filesystem image (kernel.img) data to the GRUB image\r\ngrub.img.\r\n\r\n    \r\n         # Delete old images\r\n         $ mdel -i grub.img ::kernel.img || true\r\n         $ mdel -i grub.img ::filesystem.img || true\r\n         \r\n         # Copy updated images\r\n         $ mcopy -i grub.img kernel.img :: || exit 1\r\n         $ mcopy -i grub.img filesystem.img :: || exit 1\r\n    \r\n\r\nThe `make boot' target executes mk_boot_image.sh for you.\r\n\r\n* * *\r\n\r\n\r\n## 4 Running RhythmOS\r\n\r\nOnce the kernel has been copied to the disk image, you can then run it under\r\nqemu using one of the following commands:\r\n\r\n    \r\n         $ qemu -fda src/grub.img\r\n         $ qemu -daemonize -fda src/grub.img       # daemonize qemu\r\n         $ qemu -monitor stdio -fda src/grub.img   # output qemu debug on stdio\r\n    \r\n\r\nThis same command can also be run through the make target `run`;\r\n\r\n    \r\n         $make run\r\n    \r\n\r\nTo run without using the grub.img you can pass the kernel image and filesystem\r\nimage seperatly to QEMU.\r\n\r\n    \r\n         $ qemu -kernel src/kernel.img -initrd src/filesystem.img\r\n    \r\n\r\n* * *\r\n\r\n\r\n#### 5.2.1 The Run-Time Library\r\n\r\nA major part of writing code for your a kernel is getting suckered into\r\nrewriting the run-time library, also known as `libc`. This is because the RTL\r\nis the most OS _dependent_ part of the compiler package: the C RTL provides\r\nenough functionality to allow you to write _portable_ programs, but the inner\r\nworkings of the RTL are _dependent_ on the OS in use.\r\n\r\nThe aim is to replicate the library defined by the ISO 3 C standard because\r\nthis will make porting programs to my kernel easier. Writing a non-standard\r\nlibrary will only result in having to re-write any application your trying to\r\nport; not to mention many open source projects that do conform to these\r\nstandards will be open for me to use.\r\n\r\n* * *\r\n\r\n\r\n\r\n## 9 System calls\r\n\r\n    \r\n         \r\n    \r\n    \r\n                 Source for system calls are located in syscall.c,\r\n         fscalls.c, filedesc.c, unixproc.c, pipe.c.\r\n         \r\n    \r\n    \r\n\r\nWhen the interrupt occurs, the CPU switches to kernel mode, and executes the\r\ninterrupt handler, which is actually implemented in assembler within start.s.\r\nThis pushes the register values onto the stack, and then calls the\r\n`interrupt_handler` function, which is implemented in `C`. The registers that\r\nwere put onto the stack are available as a parameter to this function, as a\r\nregs object. The interrupt handler then calls the `syscall` function, which\r\ninspects the registers to determine which system call was requested, and then\r\ndispatches to the appropriate handler function.\r\n\r\nFor example the system call `write` is implemented by the handler function\r\n`syscall_write`. The parameters to the system call may be accessed by looking\r\nat the process's stack. One of the saved registers is the stack pointer, which\r\nthe syscall function uses to determine the location in memory of the\r\nparameters, which it then passes to the handler function. The handler for the\r\nsystem call then performs whatever actions are necessary, which can include\r\nprivileged operations such as writing to any area of memory, since this code\r\nruns in kernel mode. Once the handler function returns, control is passed\r\nbackwards along the same path, until it returns to the process that was\r\npreviously executing. In some cases, such as the read or exit system calls,\r\nthe process may have been killed or suspended. If this is the case, syscall\r\nperforms a context switch, so that a different process will be executed when\r\nthe interrupt handler returns.\r\n\r\nThe `exit` system call is used by a process to terminate itself. When this\r\ncall is made, the `kill_process` function is called, and the handler function\r\nreturns the special value `-ESUSPEND`, indicating to the syscall dispatching\r\nfunction that the current process is no longer running, and it should perform\r\na context switch. Processes should always call `exit` as their last action, to\r\nindicate the kernel that they have no more instructions to be executed.\r\n\r\nList of all the syscalls RhythmOS has available:\r\n\r\n    \r\n         \r\n    \r\n    \r\n                   KERNEL             USER         LOCATION\r\n                   -----------------------------------------\r\n                   syscall_pipe       pipe         pipe.c\r\n                   syscall_getpid     getpid       syscall.c\r\n                   syscall_exit       exit         syscall.c\r\n                   syscall_write      write        syscall.c\r\n                   syscall_read       read         syscall.c\r\n                   syscall_geterrno   geterrno     syscall.c\r\n                   syscall_brk        brk          syscall.c\r\n                   syscall_send       send         syscall.c\r\n                   syscall_receive    receive      syscall.c\r\n                   syscall_kill       kill         syscall.c\r\n                   syscall_close      close        filedesc.c\r\n                   syscall_dup2       dup2         filedesc.c\r\n                   syscall_fork       fork         unixproc.c\r\n                   syscall_execve     execve       unixproc.c\r\n                   syscall_waitpid    waitpid      unixproc.c\r\n                   syscall_stat       stat         fscalls.c\r\n                   syscall_open       open         fscalls.c\r\n                   syscall_chdir      chdir        fscalls.c\r\n                   syscall_getcwd     getcwd       fscalls.c\r\n                   syscall_getdent    getdent      fscalls.c\r\n         \r\n    \r\n    \r\n\r\n* * *\r\n\r\n\r\n## 10 I/O\r\n\r\n* * *\r\n\r\n\r\n## 11 Filesystems\r\n\r\nThe contents of the root filesystem must be adequate to _boot_, _restore_,\r\nand/or _recover_ the system.\r\n\r\n•To _boot_ a system, enough must be present on the root partition to mount\r\nother filesystems. This includes utilities, configuration, boot loader\r\ninformation, and other essential start-up data.\r\n\r\n•For the _recovery_ of a system, utilities are needed by the user to diagnose\r\nand reconstruct the damaged system; these utilities need be present on the\r\nroot filesystem.\r\n\r\n•To _restore_ a system, those utilities needed to restore from system backups\r\n(on floppy, tape, etc.) must be present on the root filesystem.\r\n\r\nSee [The Root Filesystem\r\nStandards](http://www.pathname.com/fhs/pub/fhs-2.3.html#THEROOTFILESYSTEM) for\r\nmore a more indepth analysis.\r\n\r\nBelow is an example of a root filesystem /. Ones marked with an asterisk (<*>)\r\nare currently beind used by `RhythmOS`.\r\n\r\n_Rootfs file system structure_\r\n\r\n/bin    <*> Essential command binaries\r\n\r\n/boot    Static files of the boot loader\r\n\r\n/dev    Device files\r\n\r\n/etc    <*> Host-specific system configuration\r\n\r\n/lib    Essential shared libraries and kernel modules\r\n\r\n/media    Mount point for removeable media\r\n\r\n/mnt    Mount point for mounting a filesystem temporarily\r\n\r\n/opt    Add-on application software packages\r\n\r\n/sbin    Essential system binaries\r\n\r\n/srv    Data for services provided by this system\r\n\r\n/tmp    Temporary files\r\n\r\n/usr    <*> Secondary hierarchy\r\n\r\n/var    Variable data\r\n\r\n* * *\r\n\r\n\r\n## 12 Reporting bugs\r\n\r\nTo report bugs or suggest enhancements for RhythmOS, please send electronic\r\nmail to [dustindorroh@gmail.com](mailto:dustindorroh@gmail.com).\r\n\r\n## Concept index\r\n\r\n  * authors: RhythmOS Features\r\n  * Binutils: Binutils\r\n  * Bootloader Image: Bootloader Image\r\n  * bug reporting: Reporting bugs\r\n  * Build Environment: Build Environment\r\n  * Build Internals: Build Internals\r\n  * Building RhythmOS: Building RhythmOS\r\n  * C: C\r\n  * C Library: C Library\r\n  * compiler: The Run-Time Library\r\n  * Dustin, Dorroh: RhythmOS Features\r\n  * FDL, GNU Free Documentation License: Reporting bugs\r\n  * Filesystem Image: Filesystem Image\r\n  * GCC: GCC\r\n  * Generate Kernel Image: Kernel Image\r\n  * kernel: The Run-Time Library\r\n  * link.ld: link.ld\r\n  * Linker Invocation: Linker Invocation\r\n  * Linking: Linking\r\n  * open source: The Run-Time Library\r\n  * OS: The Run-Time Library\r\n  * Overview: Overview\r\n  * portable: The Run-Time Library\r\n  * problems: Reporting bugs\r\n  * reporting bugs: Reporting bugs\r\n  * RhythmOS Features: RhythmOS Features\r\n  * RTL: The Run-Time Library\r\n  * Run-Time Library: The Run-Time Library\r\n  * Source Code: Source Code\r\n  * Source Download: Source Download\r\n  * Toolchain Setup: Toolchain Setup\r\n\r\n* * *\r\n\r\n#### Footnotes\r\n\r\n[1] For example binaries will placed in rootfs/bin directory on the host\r\nmachine\r\n\r\n[2] _See_ fstool.c in the project source to see how the image is created\r\n\r\n[3] International Standardization Organization\r\n\r\n* * *\r\n","tagline":"Small UNIX like Kernel for x86","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}